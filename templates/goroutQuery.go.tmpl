{{ define "multiQuery" }}

package gen
{{ $subQueriesLen := len .Subqueries }}
{{ $makeParamStruct := .MakeParamStruct }}

{{ if .MakeParamStruct }}
type {{ .Name }}Params struct {
  {{ range $name, $type := .FunctionParams }}
  {{ $name }} {{ $type }}
  {{ end }}
}
{{ end }}

func (s *db.Store) {{ .Name }}(ctx context.Context, {{ .FuncParamName }} {{ .FuncParamType }}) (*{{ .OutType }}, error) {
  {{ range .Subqueries }}
  {{ .VarName }}Chan := make(chan {{ .ReturnType }})
  {{ end }}
  errChan := make(chan error, {{ $subQueriesLen }})


	var wg sync.WaitGroup
	wg.Add({{ $subQueriesLen }})

  {{ range .Subqueries }}
  go func() {
    defer wg.Done()
    {{ .VarName }}, err := s.Queries.{{ .Method }}(ctx, {{ if $makeParamStruct }}params.{{ end }}{{ .ParamName }})
    if err != nil {
      errChan <- fmt.Errorf("failed to get {{ .VarName }}: %w", err)
      return
    }
    {{ .VarName }}Chan <- {{ .VarName }}
	}()
  {{ end }}

	wg.Wait()
  {{ range .Subqueries }}
  close({{ .VarName }}Chan)
  {{ end }}

	for err := range errChan {
		return nil, err
	}

  {{ range .Subqueries }}
  {{ .VarName }} := <- {{ .VarName }}Chan
  {{ end }}

	return &{{ .OutType }}{
    {{ range .OutTypeFields }}
    {{ . }}: {{ lower . }}, 
    {{ end }}
	}, nil
}
{{ end }}
