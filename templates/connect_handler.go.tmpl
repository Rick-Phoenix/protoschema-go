{{ define "queryCall" }}
{{ if not .IsErr }}{{ index .ReturnTypes 0 }}, {{ end }}err := s.Queries.{{ .Name }}(ctx, req.Msg.Get())
{{ end }}
{{ define "connectHandler" }}
package handlers

{{ template "imports" .Imports }}


type {{ .Resource }}Service struct {
  Queries *db.Queries
}

func New{{ .Resource }}Service(s *db.Store) *{{ .Resource }}Service {
	return &{{ .Resource }}Service{Store: s}
}

{{ $res := .Resource }}

{{ range .Handlers }}

func (s *{{ $res }}Service) {{ .Name }}(
	ctx context.Context,
  req *connect.Request[{{ .Request.GetGoPackageName }}.{{ .Request.Name }}],
) (*connect.Response[{{ .Response.GetGoPackageName }}.{{ .Response.Name }}], error) {

  {{ if .Query }}{{ template "queryCall" .Query }}{{ end }}
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, connect.NewError(connect.CodeNotFound, err)
		} else {
			var sqliteErr *sqlite.Error
			if errors.As(err, &sqliteErr) {
				fmt.Printf("Sqlite error: %s\n", sqlite.ErrorCodeString[sqliteErr.Code()])
			} else {
				fmt.Printf("Unknown error: %s\n", err.Error())
			}
			return nil, connect.NewError(connect.CodeUnknown, err)
		}
	}

  return connect.NewResponse(&{{ .Response.GetGoPackageName }}.{{ .Response.Name }}{
    {{ if .Query }}
    {{ range $name, $_ := .Query.ReturnFields }}
    {{ $name }}: ,
    {{ end }}
    {{ end }}
	), nil
}

{{ end }}

{{ end }}
